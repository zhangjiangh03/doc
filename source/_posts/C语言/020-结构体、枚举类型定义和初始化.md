---
title: 结构体、枚举类型定义和初始化
date: 2022-12-25 13:45:00
categories:
- C语言
tags:
- C语言基础
---

结构体是一种用户自定义的数据类型，可以将多个不同类型的变量组合在一起，形成一个结构体变量。

## 结构体的定义

第一种方法：先说明结构体类型，后说明结构体变量

```text
struct 结构体名 {
    成员1类型 成员1名;
    成员2类型 成员2名;
    ...
};
```

第二种方法：在定义结构体的时候同时定义结构体变量

```text
struct 结构体名 {
    成员1类型 成员1名;
    成员2类型 成员2名;
    ...
}变量名表;
```

第三种方法：直接定义结构体变量

```text
struct{
    成员1类型 成员1名;
    成员2类型 成员2名;
    ...
}变量名表;
```

第四种方法：使用typedef说明一个结构体类型名，再用新类型名定义变量

```text
typedef struct{
    成员1类型 成员1名;
    成员2类型 成员2名;
    ...
}新类型;
新类型 变量名表;
```

其中，`结构体名`表示结构体的名称，`成员1类型`和`成员1名`表示结构体的第一个成员，依次类推。每个成员之间使用分号进行分隔。

```c
struct Person {
    char name[20];
    int age;
    char gender;
};
```

```c
struct Person {
    char name[20];
    int age;
    char gender;
}a;
```

```c
struct {
    char name[20];
    int age;
    char gender;
}a;
```

```c
typedef struct {
    char name[20];
    int age;
    char gender;
}TY;
TY s[30];
```

## 结构体变量的初始化

结构体变量可以通过两种方式进行初始化：静态初始化和动态初始化。

**给结构体变量赋初值**

```c
struct Person {
    char name[20];
    int age;
    char gender;
}a = {"Tom", 16, 'M'}, b = {"Alice", 16, 'F'};
```

**给结构体数组赋初值**

```c
struct Person {
    char name[20];
    int age;
    char gender;
}stu[3] = {{"Tom"}, 16, 'M'},
{{"Alice"}, 16, 'F'},
{{"John"}, 16, 'M'};
```

其中数组`stu[3]`中`3`可以省略，系统会根据赋初值时结构体常量的个数确定数组元素个数。

### 静态初始化

静态初始化是指在定义结构体变量时，直接给出初始值的方式。

```text
struct 结构体名 变量名 = {成员1值, 成员2值, ...};
```

```c
struct Person {
    char name[20];
    int age;
    char gender;
};

int main() {
    struct Person person = {"Tom", 20, 'M'};
    return 0;
}
```

### 动态初始化

动态初始化是指在定义结构体变量后，通过点操作符对各个成员进行赋值的方式。

```text
struct 结构体名 变量名;
变量名.成员1名 = 成员1值;
变量名.成员2名 = 成员2值;
...
```

```c
struct Person {
    char name[20];
    int age;
    char gender;
};

int main() {
    struct Person person;
    person.name = "Tom";
    person.age = 20;
    person.gender = 'M';
    return 0;
}
```

需要注意：动态初始化结构体变量时，应确保结构体变量已经分配了内存空间，否则可能会导致程序运行错误。

### 结构体内存对齐

1. 第一个成员在与结构体变量偏移量为0的地址处。 
2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。 `VS中默认的值为8`
3. 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。 
4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整 体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

**为什么存在内存对齐?**  

1. 平台原因(移植原因)： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特 定类型的数据，否则抛出硬件异常。
2. 性能原因： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访 问。总体来说： 结构体的内存对齐是拿空间来换取时间的做法。

那在设计结构体的时候，我们既要满足对齐，又要节省空间，让占用空间小的成员尽量集中在一起。

```c
struct S1
{
 char c1;
 int i;
 char c2;
};
struct S2
{
 char c1;
 char c2;
 int i;
};
```

### 修改默认对齐数

之前我们见过了`#pragma`这个预处理指令，这里我们再次使用，可以改变我们的默认对齐数。

```c
#include <stdio.h>
#pragma pack(8)//设置默认对齐数为8
struct S1
{
 char c1;
 int i;
 char c2;
};
#pragma pack()//取消设置的默认对齐数，还原为默认
#pragma pack(1)//设置默认对齐数为1
struct S2
{
 char c1;
 int i;
 char c2;
};
#pragma pack()//取消设置的默认对齐数，还原为默认
int main()
{
    //输出的结果是什么？
    printf("%d\n", sizeof(struct S1));
    printf("%d\n", sizeof(struct S2));
    return 0;
}
```

结构在对齐方式不合适的时候，我么可以自己更改默认对齐数。

### offsetof

`offsetof`是 C/C++ 中的一个宏，用于获取某个结构体成员变量相对于结构体头部的偏移量。这个偏移量是一个编译时常量。

在 C 编程中，使用 `offsetof` 宏可以方便地计算出结构体成员变量在结构体中的偏移量，从而实现对结构体成员变量的访问。使用 `offsetof` 可以避免手动计算偏移量的错误，并且使代码更加简洁、易读。

在 C/C++ 中，`offsetof` 宏定义在标准库中，头文件为 `stddef.h` 或 `cstddef`。

```text
offsetof(type, member)
```

其中，`type` 表示结构体类型，`member` 表示结构体成员变量名。

## 结构体传参

```c
struct S
{
 int data[1000];
 int num;
};
struct S s = {{1,2,3,4}, 1000};
//结构体传参
void print1(struct S s)
{
 printf("%d\n", s.num);
}
//结构体地址传参
void print2(struct S* ps)
{
 printf("%d\n", ps->num);
}
int main()
{
 print1(s);  //传结构体
 print2(&s); //传地址
 return 0;
}
```

函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。 
如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的 下降。
结构体传参的时候，要传结构体的地址。

## 位段

位段的声明和结构是类似的，有两个不同：
	位段的成员必须是`int`、`unsigned int`或`signed int`。 
	位段的成员名后边有一个冒号和一个数字。

```c
/* 结构体 */
struct A
{
 int _a;
 int _b;
 int _c;
 int _d;
};

/* 位段 */
struct A
{
 int _a:2;  //_a成员占2个bit位
 int _b:5;
 int _c:10;
 int _d:30;
};
```

### 位段的内存分配

1. 位段的成员可以是 `int` `unsigned int` `signed int` 或者是 `char` （属于整形家族）类型 
2. 位段的空间上是按照需要以4个字节（ `int` ）或者1个字节（ `char` ）的方式来开辟的。 
3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。

### 位段的跨平台问题

1. int 位段被当成有符号数还是无符号数是不确定的。
2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机
器会出问题。
3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是
舍弃剩余的位还是利用，这是不确定的。

总结：跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。

### 位段的应用

压缩存储：位段通常用于节省内存空间。在需要存储布尔值等只有 0 和 1 两个状态的数据时，使用 bool 型需要占用 1 字节（8 位），而使用位段则可以只占用 1 位，大幅节省内存。

- **位操作**
	位段的每一位都可以看做一个独立的布尔变量，可以用来表示多个开关或标志位。通过位操作的方法，我们可以高效、简洁地实现多个开关或标志位的控制，提高程序的运行效率和可维护性。
- **数据传输**
	在网络传输或文件传输等数据传输场景中，使用位段可以将数据压缩后传输，减少带宽消耗和传输时间，提高传输效率。

## 枚举

### 枚举类型的定义

```c
enum Day//星期
{
 Mon,
 Tues,
 Wed,
 Thur,
 Fri,
 Sat,
 Sun
};
enum Sex//性别
{
 MALE,
 FEMALE,
 SECRET
}；
enum Color//颜色
{
 RED,
 GREEN,
 BLUE
};
```

这些可能取值都是有值的，默认从0开始，一次递增1，当然在定义的时候也可以赋初值。

```c
enum Color//颜色
{
	RED=1,
	GREEN=2,
	BLUE=4
};
```

### 枚举的优点

1. 增加代码的可读性和可维护性
2. 和#define定义的标识符比较枚举有类型检查，更加严谨。
3. 防止了命名污染（封装）
4. 便于调试
5. 使用方便，一次可以定义多个常量

### 枚举的使用

```c
enum Color//颜色
{
	RED=1,
	GREEN=2,
	BLUE=4
};
enum Color clr = GREEN;//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。
```

