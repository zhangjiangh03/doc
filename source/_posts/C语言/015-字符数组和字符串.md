---
title: 字符数组和字符串
date: 2022-09-25 10:11:00
categories:
- C语言
tags:
- C语言基础
---

字符数组和字符串是C语言中常用的数据结构之一，字符串实际上就是一个字符数组，由系列字符组成，以`\0`表示字符串的结束。

## 字符数组

字符数组是一种用来存储字符序列的数据结构，它由若干个字符组成，`\0`作为字符数组的结束。

### 字符数组的定义

字符数组的定义分为两种方式：一种是定义时初始化，一种是定义时不初始化。

```c
char str1[6] = {'H', 'e', 'l', 'l', 'o', '\0'};     // 带初始化
char str2[6];                                       // 不带初始化
```

定义了两个长度为`6`的字符数组
`str1`字符数组使用带初始化的方式定义，赋值为字符串`Hello`；
`str2`字符数组使用了不带初始化的方式定义。
注意：在带初始化的方式定义字符数组时，数组的长度须包含`\0`，否则可能导致程序运行出错。

### 字符数组的赋值

字符数组的赋值可以通过逐个赋值或使用`strcpy()`函数来实现。
逐个赋值方式：

```c
char str[6];
str[0] = 'H';
str[1] = 'e';
str[2] = 'l';
str[3] = 'l';
str[4] = 'o';
str[5] = '\0';
```

使用`strcpy()`函数方式：

```c
char str1[6] = "Hello";
char str2[6];
strcpy(str2, str1);
```

`strcpy()`函数将`str1`中的字符串拷贝到`str2`中。

## 字符串

字符串实际上就是一个字符数组，由系列字符组成，以`\0`作为结束标志。

### 字符串的定义

字符串的定义方式包括两种：一种是使用字符数组的形式，一种是使用指向字符数组的指针形式。
字符数组形式：

```c
char str1[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

指向字符数组的指针形式：

```c
char *str2 = "Hello";
```

注意：使用指针定义字符串时，必须保证字符串的内容是只读的，不能进行修改。如果需要修改字符串的内容，可以使用字符数组的形式。

### 字符串的赋值

字符串的赋值可以通过逐个赋值和使用`strcpy()`函数来实现。
逐个赋值方式：

```c
char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

使用`strcpy()`函数方式：

```c
char str1[6] = "Hello";
char str2[6];
strcpy(str2, str1);
```

上面的代码使用了`strcpy()`函数将`str1`中的字符串拷贝到`str2`中。

- 拷贝num个字符从源字符串到目标空间。 
- 如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加0，直到num个。

### 字符串的操作

字符串和字符数组一样，也可以进行一些常见的操作。

#### `strcat()`函数

用于将两个字符串拼接在一起，将一个字符串连接到另一个字符串尾部。

```text
char * strcat ( char * destination, const char * source );
```

其中，`destination`参数是目标字符串的地址，`source`参数是源字符串的地址，两个参数都是字符型指针。
源字符串必须以`\0`结束。 目标空间必须有足够的大，能容纳下源字符串的内容。 目标空间必须可修改。

```c
char str1[20] = "Hello, ";
char str2[20] = "world!";
strcat(str1, str2);
```

`strcat()`函数将`str2`中的字符串连接到`str1`末尾。
源字符串必须以`\0`结束。 目标空间必须有足够的大，能容纳下源字符串的内容。 目标空间必须可修改。 字符串自己给自己追加。

**strcat()函数的模拟实现1（指针模拟）**

```c
char* my_strcat(char* dest, const char* src) {
    char* p = dest + strlen(dest);
    while (*src) {
        *p++ = *src++;
    }
    *p = '\0';
    return dest;
}
```

**strcat()函数的模拟实现2（数组模拟）**

```c
char* my_strcat(char* dest, const char* src) {
    int i, j;
    i = strlen(dest);
    for (j = 0; src[j] != '\0'; j++) {
        dest[i + j] = src[j];
    }
    dest[i + j] = '\0';
    return dest;
}
```

**strcat()函数的模拟实现3（递归模拟）**

```c
char* my_strcat(char* dest, const char* src) {
    if (*dest == '\0') {
        while ((*dest++ = *src++) != '\0');
    } else {
        my_strcat(++dest, src);
    }
    return dest;
}
```

#### `strcmp()`函数

用于比较两个字符串是否相同，如果相同返回`0`，否则返回`非0值`。

```c
char str1[20] = "Hello";
char str2[20] = "Hello";
int cmp = strcmp(str1, str2);
```

`strcmp()`函数比较`str1`和`str2`中的字符串是否相同。

#### `strcpy()`函数

用于将一个字符串复制到另一个字符串中。

```c
char str1[20] = "Hello";
char str2[20];
strcpy(str2, str1);
```

`strcpy()`函数将`str1`中的字符串复制到`str2`中。

- 第一个字符串大于第二个字符串，则返回大于0的数字 第一个字符串等于第二个字符串，则返回`0`
- 第一个字符串小于第二个字符串，则返回`小于0的数字

`strcpy()`会将源字符串`\0`拷贝过去。
源字符串必须以`\0`结束。 会将源字符串中的`\0`拷贝到目标空间。 目标空间必须足够大，以确保能存放源字符串。 目标空间必须可变。

**strcpy()函数的模拟实现1（指针模拟）**

```c
char* my_strcpy(char* dest, const char* src) {
    char* p = dest;
    while (*src) {
        *p++ = *src++;
    }
    *p = '\0';
    return dest;
}
```

**strcpy()函数的模拟实现2（数组模拟）**

```c
char* my_strcpy(char* dest, const char* src) {
    int i;
    for (i = 0; src[i]; i++) {
        dest[i] = src[i];
    }
    dest[i] = '\0';
    return dest;
}
```

**strcpy()函数的模拟实现3（递归模拟）**

```c
char* my_strcpy(char* dest, const char* src) {
    if (*src == '\0') {
        *dest = '\0';
        return dest;
    } else {
        *dest = *src;
        return my_strcpy(dest + 1, src + 1);
    }
}
```

#### `strlen()`函数

字符串长度计算是指获取一个字符串的长度，即字符串中字符的个数。在C语言中可以使用`strlen()`函数来计算字符串长度。

```c
#include <string.h>

int main()
{
    char str[20] = "Hello";
    int len = strlen(str);
    printf("The length of str is %d\n", len);
    return 0;
}
```

`strlen()`函数获取字符串`str`的长度，并输出结果。
字符串以`\0`作为结束标志，`strlen`函数返回的是在字符串中`\0`前面出现的字符个数（不包含`\0`)。 

```text
size_t strlen ( const char * str ); 
```

参数指向的字符串必须要以`\0`结束。 注意函数的返回值为`size_t`，是**无符号**的.

**strlen函数的模拟实现1（计数器模拟）**

```c
size_t my_strlen(const char *str) {
    size_t len = 0;
    while (*str++) {
        len++;
    }
    return len;
}
```

**strlen函数的模拟实现2（递归模拟）**

```c
size_t my_strlen(const char* str) {
    if (*str == '\0') {
        return 0;
    } else {
        return my_strlen(str + 1) + 1;
    }
}

```

**strlen函数的模拟实现3（指针模拟）**

```c
size_t my_strlen(const char* str) {
    const char* p = str;
    while (*p) {
        p++;
    }
    return p - str;
}

```

#### `strstr()`函数

子字符串查找是指在一个字符串中查找另一个子字符串的位置。在C语言中可以使用`strstr()`函数来实现子字符串查找。

```c
#include <string.h>

int main()
{
    char str[20] = "Hello, world!";
    char sub[10] = "world";
    char *ptr = strstr(str, sub);
    if (ptr != NULL) {
        printf("Found the sub string: %s\n", ptr);
    }
    else {
        printf("Sub string not found.\n");
    }
    return 0;
}
```

`strstr()`函数在字符串`str`中查找子字符串`sub`的位置，并输出结果。

```text
char * strstr ( const char *str1, const char * str2);
```

```c
#include <stdio.h>
#include <string.h>
int main ()
{
  char str[] ="This is a simple string";
  char * pch;
  pch = strstr (str,"simple");
  strncpy (pch,"sample",6);
  puts (str);
  return 0;
}
```

#### `strtok()`函数

字符串分割是指将一个字符串按照指定的分隔符分割成多个子字符串。在C语言中可以使用`strtok()`函数来实现字符串分割。

```c
#include <stdio.h>
#include <string.h>

int main()
{
    char str[20] = "Hello,world";
    char *ptr = strtok(str, ",");
    while(ptr != NULL) {
        printf("%s\n", ptr);
        ptr = strtok(NULL, ",");
    }
    return 0;
}
```

`strtok()`函数将字符串`str`按照逗号分隔符分割成多个子字符串，并输出结果。

```text
char * strtok ( char * str, const char * sep );
```

- sep参数是个字符串，定义了用作分隔符的字符集合 第一个参数指定一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记。
- strtok函数找到str中的下一个标记，并将其用 \0 结尾，返回一个指向这个标记的指针。（注：strtok函数会改变被操作的字符串，所以在使用strtok函数切分的字符串一般都是临时拷贝的内容并且可修改。）
- strtok函数的第一个参数不为 NULL ，函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置。
- strtok函数的第一个参数为 NULL ，函数将在同一个字符串中被保存的位置开始，查找下一个标记。
- 如果字符串中不存在更多的标记，则返回 NULL 指针。

```c
#include <stdio.h>
#include <string.h>
int main ()
{
  char str[] ="- This, a sample string.";
  char * pch;
  printf ("Splitting string \"%s\" into tokens:\n",str);
  pch = strtok (str," ,.-");
  while (pch != NULL)
 {
    printf ("%s\n",pch);
    pch = strtok (NULL, " ,.-");
 }
  return 0;
}
```

```c
#include <stdio.h>
int main()
{
   char *p = "zhangpengwei@bitedu.tech";
 const char* sep = ".@";
 char arr[30];
 char *str = NULL;
 strcpy(arr, p);//将数据拷贝一份，处理arr数组的内容
 for(str=strtok(arr, sep); str != NULL; str=strtok(NULL, sep))
 {
 printf("%s\n", str);
 }
}
```

#### `strncpy()`函数

```text
char * strncpy ( char * destination, const char * source, size_t num );
```

拷贝num个字符从源字符串到目标空间。 如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加0，直到num个。

#### `strncat()`函数

```text
char * strncat ( char * destination, const char * source, size_t num );
```

#### `strncmp()`函数

```text
int strncmp ( const char * str1, const char * str2, size_t num );
```

```c
#include <stdio.h>
#include <string.h>
int main ()
{
  char str[][5] = { "R2D2" , "C3PO" , "R2A6" };
  int n;
  puts ("Looking for R2 astromech droids...");
  for (n=0 ; n<3 ; n++)
  if (strncmp (str[n],"R2xx",2) == 0)
 {
    printf ("found %s\n",str[n]);
 }
  return 0;
}
```

#### `strerror()`函数

```text
char * strerror ( int errnum );
```

```c
#include <stdio.h>
#include <string.h>
#include <errno.h>//必须包含的头文件
int main ()
{
  FILE * pFile;
  pFile = fopen ("unexist.ent","r");
  if (pFile == NULL)
    printf ("Error opening file unexist.ent: %s\n",strerror(errno));
    //errno: Last error number
  return 0;
}
Edit & Run
```

#### `memcpy()`函数

```text
void * memcpy ( void * destination, const void *, source, size_t num );
```

- 函数memcpy从source的位置开始向后复制num个字节的数据到destination的内存位置。
- 这个函数在遇到`\0`的时候并不会停下来。
- 如果source和destination有任何的重叠，复制的结果都是未定义的。

```c
#include <stdio.h>
#include <string.h>
struct {
  char name[40];
  int age;
} person, person_copy;
int main ()
{
  char myname[] = "Pierre de Fermat";
  /* using memcpy to copy string: */
  memcpy ( person.name, myname, strlen(myname)+1 );
  person.age = 46;
  /* using memcpy to copy structure: */
  memcpy ( &person_copy, &person, sizeof(person) );
  printf ("person_copy: %s, %d \n", person_copy.name, person_copy.age );
  return 0;
}
```

#### `memmove()`函数

```text
void * memmove ( void * destination, const void * source, size_t num );
```

- 和memcpy的差别就是memmove函数处理的源内存块和目标内存块是可以重叠的。
- 如果源空间和目标空间出现重叠，就得使用memmove函数处理。

```c
#include <stdio.h>
#include <string.h>
int main ()
{
  char str[] = "memmove can be very useful......";
  memmove (str+20,str+15,11);
  puts (str);
  return 0;
}
```

#### `memcmp()`函数

```text
int memcmp ( const void * ptr1,
 const void * ptr2,
 size_t num );
```

比较从ptr1和ptr2指针开始的num个字节

```c
#include <stdio.h>
#include <string.h>
int main ()
{
  char buffer1[] = "DWgaOtP12df0";
  char buffer2[] = "DWGAOTP12DF0";
  int n;
  n=memcmp ( buffer1, buffer2, sizeof(buffer1) );
  if (n>0) printf ("'%s' is greater than '%s'.\n",buffer1,buffer2);
  else if (n<0) printf ("'%s' is less than '%s'.\n",buffer1,buffer2);
  else printf ("'%s' is the same as '%s'.\n",buffer1,buffer2);
  return 0;
}
```

#### 字符分类函数

|函数|如果他的参数符合下列条件就返回真|
|:--:|:--|
|iscntrl|任何控制字符|
|isspace|空白字符：空格‘ ’，换页‘\f’，换行'\n'，回车‘\r’，制表符'\t'或者垂直制表符'\v'|
|isdigit|十进制数字 0~9|
|isxdigit|十六进制数字，包括所有十进制数字，小写字母a~f，大写字母A~F|
|islower|小写字母a~z|
|isupper|大写字母A~Z|
|isalpha|字母a~z或A~Z|
|isalnum|字母或者数字，a~z,A~Z,0~9|
|ispunct|标点符号，任何不属于数字或者字母的图形字符（可打印）|
|isgraph|任何图形字符|
|isprint|任何可打印字符，包括图形字符和空白字符|

#### 字符转换

当输入为小写字母时，`toupper()`函数将其转换为对应的大写字母；
而`tolower()`函数则将其转换为对应的小写字母。如果输入不是一个字母，则函数将返回原始字符。

```text
int tolower ( int c );
int toupper ( int c );
```

```c
#include <stdio.h>
#include <ctype.h>
int main ()
{
  int i=0;
  char str[]="Test String.\n";
  char c;
  while (str[i])
 {
    c=str[i];
    if (isupper(c))
        c=tolower(c);
    putchar (c);
    i++;
 }
  return 0;
```